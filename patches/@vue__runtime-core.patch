diff --git a/dist/runtime-core.d.ts b/dist/runtime-core.d.ts
index dd923affe8c0d37c055188e95d0db8a3ebdf1a7a..fcc52415a6b8788986d2c5bbd667265c45e018bd 100644
--- a/dist/runtime-core.d.ts
+++ b/dist/runtime-core.d.ts
@@ -1,6 +1,7 @@
 import { computed as computed$1, Ref, OnCleanup, WatchStopHandle, ShallowUnwrapRef, UnwrapNestedRefs, DebuggerEvent, ComputedGetter, WritableComputedOptions, WatchCallback, ReactiveEffect, DebuggerOptions, WatchEffect, WatchHandle, WatchSource, ReactiveMarker, ShallowRef, WatchErrorCodes, reactive } from '@vue/reactivity';
 export { ComputedGetter, ComputedRef, ComputedSetter, CustomRefFactory, DebuggerEvent, DebuggerEventExtraInfo, DebuggerOptions, DeepReadonly, EffectScheduler, EffectScope, MaybeRef, MaybeRefOrGetter, Raw, Reactive, ReactiveEffect, ReactiveEffectOptions, ReactiveEffectRunner, ReactiveFlags, Ref, ShallowReactive, ShallowRef, ShallowUnwrapRef, ToRef, ToRefs, TrackOpTypes, TriggerOpTypes, UnwrapNestedRefs, UnwrapRef, WatchCallback, WatchEffect, WatchHandle, WatchSource, WatchStopHandle, WritableComputedOptions, WritableComputedRef, customRef, effect, effectScope, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, onWatcherCleanup, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, triggerRef, unref } from '@vue/reactivity';
 import { IfAny, Prettify, LooseRequired, UnionToIntersection, OverloadParameters, IsKeyValues } from '@vue/shared';
+export { LooseRequired } from '@vue/shared';
 export { camelize, capitalize, normalizeClass, normalizeProps, normalizeStyle, toDisplayString, toHandlerKey } from '@vue/shared';
 
 export declare const computed: typeof computed$1;
@@ -323,7 +324,7 @@ export declare function defineModel<T, M extends PropertyKey = string, G = T, S
 }) & PropOptions<T> & DefineModelOptions<T, G, S>): ModelRef<T, M, G, S>;
 export declare function defineModel<T, M extends PropertyKey = string, G = T, S = T>(name: string, options?: PropOptions<T> & DefineModelOptions<T, G, S>): ModelRef<T | undefined, M, G | undefined, S | undefined>;
 type NotUndefined<T> = T extends undefined ? never : T;
-type MappedOmit<T, K extends keyof any> = {
+export type MappedOmit<T, K extends keyof any> = {
     [P in keyof T as P extends K ? never : P]: T[P];
 };
 type InferDefaults<T> = {
